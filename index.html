<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bird Murmuration Simulator</title>
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas and controls */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Deep Slate background for the environment */
            color: #d1d5db;
            overflow: hidden; /* Prevent body scroll */
        }
        #simulationCanvas {
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            cursor: move; /* Indicate dragging behavior */
            touch-action: none; /* Disable default touch actions */
        }
        /* REDUCED WIDTH HERE */
        .control-label {
            min-width: 120px;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body class="p-4 md:p-8 flex flex-col h-screen">

    <!-- REDUCED MARGIN --><h1 class="text-3xl font-extrabold text-center mb-2 text-white">
        Flock Simulation (Sunset Murmuration)
    </h1>

    <!-- Flocking Controls - REDUCED PADDING, SPACING, AND MARGIN --><div class="flex flex-wrap items-center justify-center space-y-2 md:space-y-0 md:space-x-4 mb-3 p-3 bg-gray-700/50 rounded-xl shadow-lg">
        
        <!-- Bird Count Slider --><div class="flex items-center space-x-3 w-full md:w-auto">
            <label for="birdCount" class="control-label text-sm font-medium">Bird Count (<span id="arrivedCount" class="text-green-400 font-bold">0</span> Roosted):</label>
            <input type="range" id="birdCount" min="1" max="500" value="100" class="w-full h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer range-lg">
            <span id="currentBirdCount" class="text-lg font-bold w-12 text-right">100</span>
        </div>

        <!-- Button Group: Add and Reset -->
        <div class="flex space-x-4">
            <!-- Add Birds Button -->
            <button id="addBirdsButton" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out">
                +25 Birds (Start Arrival)
            </button>
            <!-- Reset Button -->
            <button id="resetButton" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out">
                Reset Simulation
            </button>
        </div>

        <!-- Cohesion Slider --><div class="flex items-center space-x-3 w-full md:w-auto">
            <label for="cohesionFactor" class="control-label text-sm font-medium">Cohesion:</label>
            <input type="range" id="cohesionFactor" min="0" max="2" step="0.05" value="1" class="w-full h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
        </div>

        <!-- Separation Slider --><div class="flex items-center space-x-3 w-full md:w-auto">
            <label for="separationFactor" class="control-label text-sm font-medium">Separation:</label>
            <input type="range" id="separationFactor" min="0" max="2" step="0.05" value="1.5" class="w-full h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
        </div>

        <!-- Alignment Slider --><div class="flex items-center space-x-3 w-full md:w-auto">
            <label for="alignmentFactor" class="control-label text-sm font-medium">Alignment:</label>
            <input type="range" id="alignmentFactor" min="0" max="2" step="0.05" value="1" class="w-full h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer">
        </div>
    </div>
    
    <!-- Wind Controls - REDUCED PADDING, SPACING, AND MARGIN --><div class="flex flex-wrap items-center justify-center space-y-2 md:space-y-0 md:space-x-4 mb-3 p-3 bg-gray-700/50 rounded-xl shadow-lg">
        <!-- Removed h2 margin for more space --><h2 class="text-xl font-semibold">Wind Settings:</h2>
        
        <!-- Wind Speed Input --><div class="flex items-center space-x-3 w-full md:w-auto">
            <label for="windSpeed" class="control-label text-sm font-medium">Speed (Knots):</label>
            <input type="number" id="windSpeed" min="0" max="20" value="0" class="w-20 bg-gray-600 rounded-lg text-center p-1 text-sm focus:ring-blue-500 focus:border-blue-500">
        </div>
        
        <!-- Wind Direction Selection --><div class="flex items-center space-x-4 w-full md:w-auto">
            <label class="control-label text-sm font-medium">Wind Origin:</label>
            <div class="flex space-x-3">
                <label class="inline-flex items-center cursor-pointer">
                    <input type="radio" name="windSource" value="left" id="windFromLeft" checked class="form-radio text-blue-500 bg-gray-600 border-gray-500">
                    <span class="ml-2">From Left (Push Right)</span>
                </label>
                <label class="inline-flex items-center cursor-pointer">
                    <input type="radio" name="windSource" value="right" id="windFromRight" class="form-radio text-blue-500 bg-gray-600 border-gray-500">
                    <span class="ml-2">From Right (Push Left)</span>
                </label>
            </div>
        </div>
    </div>

    <!-- Canvas Container --><div id="canvas-container" class="flex-grow min-h-0">
        <canvas id="simulationCanvas" class="w-full h-full"></canvas>
    </div>

    <script>
        // Global Constants and Setup
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // UI Element References
        const birdCountInput = document.getElementById('birdCount');
        const currentBirdCountSpan = document.getElementById('currentBirdCount');
        const arrivedCountSpan = document.getElementById('arrivedCount');
        const cohesionFactorInput = document.getElementById('cohesionFactor');
        const separationFactorInput = document.getElementById('separationFactor');
        const alignmentFactorInput = document.getElementById('alignmentFactor');
        const windSpeedInput = document.getElementById('windSpeed');
        const windFromLeftInput = document.getElementById('windFromLeft');
        const windFromRightInput = document.getElementById('windFromRight');
        const addBirdsButton = document.getElementById('addBirdsButton'); 
        const resetButton = document.getElementById('resetButton'); 

        // Physics constants
        const MAX_SPEED = 2.5; 
        const PERCEPTION_RADIUS = 50;
        const BIRD_SIZE = 2; 
        const EDGE_MARGIN = 50; 
        const BOTTOM_EDGE_MARGIN_MULTIPLIER = 2; 
        const ARRIVAL_INTERVAL_MS = 310; 
        const ROOST_TARGET_FORCE = 0.15; 
        const ROOST_STOPPING_RADIUS = 10; 
        const ROOST_PEEL_INTERVAL_MS = 1000; 
        const WIND_SCALE_FACTOR = 0.005; 
        const ARRIVAL_SLOW_RADIUS = 100; 
        const INSTANT_ADD_COUNT = 25; 
        const INITIAL_BIRD_COUNT = 100; // Define initial count for easy reset

        // Constants for Flocking/Roosting Behavior
        const FLOCK_SETTLE_DELAY_MS = 5000; 
        // Massive radius for flock formation around the roosting site
        const ROOST_GOAL_RADIUS = 8000; 
        // Force applied to the flocking center to pull it toward the roost
        const ROOST_GOAL_FORCE_MULTIPLIER = 0.02; // Keeps the dense flock centered over the tree
        const BASE_SEPARATION_DISTANCE_MULTIPLIER = 4; // Base multiplier for bird radius
        // Multiplier for massive, dispersed holding pattern - set to 30
        const HOLDING_SEPARATION_MULTIPLIER = 1.875; // HALVED from 3.75 to 1.875
        // Factor to slow down birds once the main flock has formed (speed remains MAX_SPEED)
        const FLOCKING_SPEED_REDUCTION_FACTOR = 1.0; 

        // --- Tree/Roosting Shape Constants and Variables ---
        const TRUNK_WIDTH = 16;
        const CANOPY_RADIUS = 40;
        const TREE_HEIGHT = 100;
        const TREE_BASE_Y_OFFSET = 50;
        
        let treeCenterX = 0;
        let canopyCenterY = 0;
        let treeBaseY = 0;
        // ---------------------------------------------------

        // Utility: Vector Class (simple implementation)
        class Vector {
            constructor(x, y) {
                this.x = x || 0;
                this.y = y || 0;
            }

            add(other) {
                return new Vector(this.x + other.x, this.y + other.y);
            }

            sub(other) {
                return new Vector(this.x - other.x, this.y - other.y);
            }

            mult(scalar) {
                return new Vector(this.x * scalar, this.y * scalar);
            }

            div(scalar) {
                return new Vector(this.x / scalar, this.y / scalar);
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            setMag(magnitude) {
                if (this.mag() === 0) return new Vector(magnitude, 0);
                return this.normalize().mult(magnitude);
            }

            normalize() {
                const m = this.mag();
                if (m === 0) return new Vector(0, 0);
                return this.div(m);
            }

            limit(max) {
                if (this.mag() > max) {
                    return this.setMag(max);
                }
                return new Vector(this.x, this.y);
            }
        }

        // Global State Variables
        let birds = [];
        let attractionPoint = null; 
        let additionInterval = null; 
        let peelInterval = null; 
        let settleTimeout = null; 
        let targetBirdCount = INITIAL_BIRD_COUNT;
        let isFlockFormed = false; 
        let roostingSite = new Vector(0, 0); 


        // Bird (Boid) Class
        class Bird {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1).setMag(Math.random() * MAX_SPEED);
                this.acceleration = new Vector(0, 0);
                this.color = '#FFFFFF'; // White silhouette
                this.radius = BIRD_SIZE;
                this.roostingState = 'FLOCKING'; // 'FLOCKING', 'ROOSTING', or 'ROOSTED'
                this.roostTarget = null; // Unique landing spot for this bird
            }

            getNeighbors(birds) {
                const neighbors = [];
                for (let other of birds) {
                    if (other !== this && other.roostingState !== 'ROOSTED') { 
                        const distance = this.position.sub(other.position).mag();
                        if (distance < PERCEPTION_RADIUS) {
                            neighbors.push(other);
                        }
                    }
                }
                return neighbors;
            }

            cohesion(neighbors, factor) {
                if (neighbors.length === 0) return new Vector(0, 0);
                let centerOfMass = new Vector(0, 0);
                for (let other of neighbors) {
                    centerOfMass = centerOfMass.add(other.position);
                }
                centerOfMass = centerOfMass.div(neighbors.length);
                let steering = centerOfMass.sub(this.position);
                steering = steering.setMag(MAX_SPEED);
                steering = steering.sub(this.velocity);
                steering = steering.limit(factor * 0.2); 
                return steering;
            }

            /**
             * Calculates separation force.
             * @param {Array<Bird>} neighbors - Nearby birds.
             * @param {number} factor - User-defined separation strength.
             * @param {number} separationDistance - The distance threshold for feeling separation force.
             */
            separation(neighbors, factor, separationDistance) {
                let steering = new Vector(0, 0);
                let total = 0;

                for (let other of neighbors) {
                    const distance = this.position.sub(other.position).mag();
                    // Use the dynamic separationDistance
                    if (distance > 0 && distance < separationDistance) { 
                        let diff = this.position.sub(other.position);
                        diff = diff.normalize().div(distance * distance); 
                        steering = steering.add(diff);
                        total++;
                    }
                }

                if (total > 0) {
                    steering = steering.div(total);
                    steering = steering.setMag(MAX_SPEED);
                    steering = steering.sub(this.velocity);
                    steering = steering.limit(factor * 0.3); 
                }
                return steering;
            }

            alignment(neighbors, factor) {
                if (neighbors.length === 0) return new Vector(0, 0);
                let avgVelocity = new Vector(0, 0);
                for (let other of neighbors) {
                    avgVelocity = avgVelocity.add(other.velocity);
                }
                avgVelocity = avgVelocity.div(neighbors.length);

                avgVelocity = avgVelocity.setMag(MAX_SPEED);
                let steering = avgVelocity.sub(this.velocity);
                steering = steering.limit(factor * 0.2); 
                return steering;
            }

            /**
             * Calculates an aggressive, distance-based steering force to push birds away from the edges.
             * This prevents them from getting stuck in corners.
             */
            avoidEdges() {
                let steering = new Vector(0, 0);
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const margin = EDGE_MARGIN;
                const bottomMargin = margin * BOTTOM_EDGE_MARGIN_MULTIPLIER;
                
                // Increased max force contribution to make walls feel more "solid"
                const maxForceContribution = 0.8; 

                // Helper function to calculate avoidance force for one boundary
                const calculateForce = (distance, maxDistance, desiredDirection) => {
                    if (distance < maxDistance) {
                        // Calculate strength: closer to 0 distance means closer to 1 strength
                        const strength = 1 - (distance / maxDistance); 
                        // Use strength squared to make the push exponential (very gentle far away, very strong close up)
                        return desiredDirection.mult(maxForceContribution * strength * strength); 
                    }
                    return new Vector(0, 0);
                };

                // 1. Left Edge (push right)
                steering = steering.add(calculateForce(
                    this.position.x, 
                    margin, 
                    new Vector(1, 0)
                ));

                // 2. Right Edge (push left)
                steering = steering.add(calculateForce(
                    canvasWidth - this.position.x, 
                    margin, 
                    new Vector(-1, 0)
                ));

                // 3. Top Edge (push down)
                steering = steering.add(calculateForce(
                    this.position.y, 
                    margin, 
                    new Vector(0, 1)
                ));

                // 4. Bottom Edge (push up, using larger margin)
                steering = steering.add(calculateForce(
                    canvasHeight - this.position.y, 
                    bottomMargin, 
                    new Vector(0, -1)
                ));
                
                // Limit the overall steering force (increased from 0.4 to 0.6 for better corner rejection)
                return steering.limit(0.6); 
            }

            seekAttraction(target) {
                if (!target) return new Vector(0, 0);

                let desired = target.sub(this.position);
                desired = desired.setMag(MAX_SPEED);
                
                let steering = desired.sub(this.velocity);
                steering = steering.limit(0.1); 
                return steering;
            }

            applyForce(force) {
                this.acceleration = this.acceleration.add(force);
            }

            flock(allBirds) {
                // 1. Static check
                if (this.roostingState === 'ROOSTED') {
                    this.velocity = new Vector(0, 0);
                    this.acceleration = new Vector(0, 0);
                    return; 
                }

                // 4. Roosting Force (Override for the selected bird)
                if (this.roostingState === 'ROOSTING' && this.roostTarget) {
                    // This state completely overrides the flocking behavior
                    let desired = this.roostTarget.sub(this.position);
                    const distance = desired.mag(); 
                    
                    if (distance < ROOST_STOPPING_RADIUS) {
                        this.roostingState = 'ROOSTED';
                        this.velocity = new Vector(0, 0);
                        this.acceleration = new Vector(0, 0);
                        this.color = '#AAAAAA'; 
                        updateArrivedCount(); 
                        return;
                    }

                    if (distance > 0) {
                        desired = desired.normalize(); 
                        
                        let speed = MAX_SPEED;
                        if (distance < ARRIVAL_SLOW_RADIUS) {
                            speed = MAX_SPEED * (distance / ARRIVAL_SLOW_RADIUS);
                        }

                        desired = desired.mult(speed); 
                        
                        let steering = desired.sub(this.velocity);
                        steering = steering.limit(ROOST_TARGET_FORCE);
                        
                        // Clear all previous accumulation and apply ONLY the steering toward the roost
                        this.acceleration = new Vector(0, 0);
                        this.applyForce(steering);
                    }
                    return; // Crucial: skip flocking logic when roosting
                }


                // --- FLOCKING LOGIC APPLIES HERE ---

                const neighbors = this.getNeighbors(allBirds);
                const cohesionFactor = parseFloat(cohesionFactorInput.value);
                const separationFactor = parseFloat(separationFactorInput.value);
                const alignmentFactor = parseFloat(alignmentFactorInput.value);

                // Determine separation distance multiplier
                let sepDistanceMultiplier = 1;
                const BASE_SEPARATION_DISTANCE = this.radius * BASE_SEPARATION_DISTANCE_MULTIPLIER;

                // When flock is formed and holding, use the massive separation distance
                if (isFlockFormed) {
                    sepDistanceMultiplier = HOLDING_SEPARATION_MULTIPLIER; 
                }
                const actualSeparationDistance = BASE_SEPARATION_DISTANCE * sepDistanceMultiplier;

                const sep = this.separation(neighbors, separationFactor, actualSeparationDistance);
                const coh = this.cohesion(neighbors, cohesionFactor);
                const ali = this.alignment(neighbors, alignmentFactor);
                const edgeAvoidance = this.avoidEdges(); 
                const attraction = this.seekAttraction(attractionPoint);
                const windForce = calculateWindForce();

                // 2. Roost Goal Force (Applies only if the bird is actively FLOCKING)
                let roostGoal = new Vector(0, 0);
                if (isFlockFormed) {
                    const flockCenter = getFlockingCenter();
                    if (flockCenter) {
                        const distanceToRoost = flockCenter.sub(roostingSite).mag();
                        
                        if (distanceToRoost < ROOST_GOAL_RADIUS) {
                            let desired = roostingSite.sub(this.position);
                            const goalStrength = 1 - (distanceToRoost / ROOST_GOAL_RADIUS); 

                            desired = desired.setMag(MAX_SPEED * goalStrength);
                            
                            let steering = desired.sub(this.velocity);
                            steering = steering.limit(ROOST_GOAL_FORCE_MULTIPLIER);
                            roostGoal = steering;
                        }
                    }
                    // *** CENTRAL CORRIDOR CONSTRAINT REMOVED HERE ***
                }

                // 3. Apply general forces
                this.applyForce(sep);
                this.applyForce(coh);
                this.applyForce(ali);
                this.applyForce(edgeAvoidance); 
                this.applyForce(attraction);
                this.applyForce(windForce);
                this.applyForce(roostGoal);
            }

            update() {
                if (this.roostingState === 'ROOSTED') {
                    return;
                }
                
                this.velocity = this.velocity.add(this.acceleration);
                
                // Determine the maximum speed based on the flocking state (speed is modified here by the FLOCKING_SPEED_REDUCTION_FACTOR)
                let currentMaxSpeed = MAX_SPEED;
                if (isFlockFormed && this.roostingState === 'FLOCKING') {
                    currentMaxSpeed = MAX_SPEED * FLOCKING_SPEED_REDUCTION_FACTOR; 
                }

                this.velocity = this.velocity.limit(currentMaxSpeed);
                this.position = this.position.add(this.velocity);
                this.acceleration = this.acceleration.mult(0); 

                this.position.x = Math.max(0, Math.min(canvas.width, this.position.x));
                this.position.y = Math.max(0, Math.min(canvas.height, this.position.y));
            }

            draw() {
                const angle = this.roostingState === 'FLOCKING' || this.roostingState === 'ROOSTING' 
                    ? Math.atan2(this.velocity.y, this.velocity.x) 
                    : 0; 
                
                const size = this.radius * 2.5; 
                const width = this.radius * 1.5; 

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(angle);

                ctx.beginPath();
                
                if (this.roostingState === 'ROOSTED') {
                    ctx.arc(0, 0, this.radius + 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = this.color; 
                    ctx.fill();
                } else {
                    // V-shape silhouette for flying birds
                    ctx.moveTo(size, 0); 
                    ctx.lineTo(-size * 0.5, -width);
                    ctx.lineTo(0, 0); 
                    ctx.lineTo(-size * 0.5, width);
                    ctx.lineTo(size, 0);
                    ctx.fillStyle = this.color; 
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // --- Core Simulation Functions ---

        /**
         * Generates a random target vector that falls within the visual shape of the tree (Canopy or Trunk).
         */
        function generateRoostTarget() {
            // 60% chance to land in canopy, 40% in trunk
            if (Math.random() < 0.6) {
                // --- Canopy Landing (Circle centered at canopyCenterY) ---
                // Find a random point within the canopy circle
                let angle = Math.random() * Math.PI * 2;
                let radius = Math.random() * CANOPY_RADIUS * 0.8; // Use 80% of radius to keep off the edge
                
                let offsetX = Math.cos(angle) * radius;
                let offsetY = Math.sin(angle) * radius;
                
                return new Vector(treeCenterX + offsetX, canopyCenterY + offsetY);

            } else {
                // --- Trunk Landing (Rectangle from canopy base down to tree base) ---
                // X: within trunk width
                let x = treeCenterX + (Math.random() * TRUNK_WIDTH - TRUNK_WIDTH / 2);
                
                // Y: between canopy center Y (top of trunk area) and treeBaseY (bottom)
                let yMin = canopyCenterY; 
                let yMax = treeBaseY;
                
                let y = yMin + (Math.random() * (yMax - yMin));

                return new Vector(x, y);
            }
        }

        /**
         * Calculates the center of mass for all birds currently active (FLOCKING or ROOSTING).
         */
        function getFlockingCenter() {
            let center = new Vector(0, 0);
            const flockingBirds = birds.filter(b => b.roostingState === 'FLOCKING' || b.roostingState === 'ROOSTING');
            
            if (flockingBirds.length === 0) {
                return null;
            }
            
            for (const bird of flockingBirds) {
                center = center.add(bird.position);
            }
            
            return center.div(flockingBirds.length);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;

            // Update Tree Coordinates
            treeBaseY = canvas.height - TREE_BASE_Y_OFFSET;
            treeCenterX = canvas.width / 2;
            canopyCenterY = treeBaseY - TREE_HEIGHT * 0.3;

            // Roosting site is the center of the canopy, used as the main flock attraction point
            roostingSite = new Vector(
                treeCenterX, 
                canopyCenterY + CANOPY_RADIUS / 4 // Adjusting slightly lower for better flock approach
            ); 
        }

        function drawSunset() {
            // Draw a linear gradient from deep orange (bottom/horizon) to dark blue (top/sky)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f172a'); 
            gradient.addColorStop(0.3, '#1e3a8a'); 
            gradient.addColorStop(1, '#9a3412'); 
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- Roosting Tree Drawing (Horizontal Center, Bottom) ---
            
            // Draw Trunk
            ctx.fillStyle = '#452a1a'; // Brown
            // Uses the globally calculated treeCenterX and treeBaseY
            ctx.fillRect(treeCenterX - TRUNK_WIDTH / 2, treeBaseY, TRUNK_WIDTH, -TREE_HEIGHT * 0.3);

            // Draw Canopy
            ctx.beginPath();
            ctx.arc(treeCenterX, canopyCenterY, CANOPY_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#1e381b'; // Dark Green/Brownish for sunset tree
            ctx.fill();
            ctx.closePath();
            // --- End Roosting Tree ---
        }

        function calculateWindForce() {
            const speedKnots = parseFloat(windSpeedInput.value) || 0;

            if (speedKnots === 0) return new Vector(0, 0);

            const scale = speedKnots * WIND_SCALE_FACTOR;
            let xForce = 0;
            
            if (windFromLeftInput.checked) {
                xForce = scale;
            } else if (windFromRightInput.checked) {
                xForce = -scale;
            }
            
            return new Vector(xForce, 0);
        }

        function loop() {
            drawSunset();

            for (let bird of birds) {
                bird.flock(birds);
                bird.update();
                bird.draw();
            }

            requestAnimationFrame(loop);
        }

        // Function to manage the sequential roosting process
        function startRoostingPeel() {
            if (peelInterval !== null) return; 

            peelInterval = setInterval(() => {
                const flockingBirds = birds.filter(b => b.roostingState === 'FLOCKING');

                if (flockingBirds.length > 0) {
                    const birdToRoost = flockingBirds[Math.floor(Math.random() * flockingBirds.length)];
                    
                    // Assign a unique random target spot for this bird based on tree shape
                    birdToRoost.roostTarget = generateRoostTarget();
                    birdToRoost.roostingState = 'ROOSTING';

                } else if (birds.length > 0 && birds.every(b => b.roostingState !== 'ROOSTING')) {
                    // All birds are either ROOSTED or are currently ROOSTING. If none are ROOSTING, they must all be ROOSTED.
                    clearInterval(peelInterval);
                    peelInterval = null;
                }
            }, ROOST_PEEL_INTERVAL_MS);
        }

        // Function to update the roosted bird counter
        function updateArrivedCount() {
            const roostedCount = birds.filter(b => b.roostingState === 'ROOSTED').length;
            arrivedCountSpan.textContent = `${roostedCount}`;
        }

        // --- Incremental Addition Logic ---
        
        function addSingleBird() {
            if (birds.length < targetBirdCount) {
                let startX;
                let initialVelX;
                
                const isComingFromLeft = Math.random() < 0.5; 

                if (isComingFromLeft) {
                    startX = 0; 
                    initialVelX = Math.random() * 0.5 + 0.5; 
                } else {
                    startX = canvas.width; 
                    initialVelX = Math.random() * -0.5 - 0.5; 
                }

                const newBird = new Bird(
                    startX, 
                    Math.random() * canvas.height 
                );

                newBird.velocity = new Vector(
                    initialVelX, 
                    Math.random() * 2 - 1
                ).setMag(Math.random() * MAX_SPEED); 

                birds.push(newBird);

            } else {
                // All birds have arrived
                clearInterval(additionInterval);
                additionInterval = null;
                
                // NEW: Wait for the flock to settle before starting the roosting peel
                if (settleTimeout) clearTimeout(settleTimeout);
                
                settleTimeout = setTimeout(() => {
                    isFlockFormed = true; 
                    startRoostingPeel();
                    settleTimeout = null;
                }, FLOCK_SETTLE_DELAY_MS);
            }
        }
        
        function increaseTargetCount() {
            const maxBirds = parseInt(birdCountInput.max, 10);
            
            let newTarget = targetBirdCount + INSTANT_ADD_COUNT;
            
            if (newTarget > maxBirds) {
                newTarget = maxBirds;
            }
            
            birdCountInput.value = newTarget;
            handleBirdCountChange(); 
        }

        /**
         * Clears all birds, stops all timers, and resets the simulation to the initial state (100 birds).
         */
        function resetSimulation() {
            // 1. Stop all intervals and timeouts
            if (additionInterval) {
                clearInterval(additionInterval);
                additionInterval = null;
            }
            if (peelInterval) {
                clearInterval(peelInterval);
                peelInterval = null;
            }
            if (settleTimeout) {
                clearTimeout(settleTimeout);
                settleTimeout = null;
            }
            
            // 2. Reset global state
            birds = [];
            isFlockFormed = false;
            attractionPoint = null;

            // 3. Reset UI controls and target count
            birdCountInput.value = INITIAL_BIRD_COUNT;
            targetBirdCount = INITIAL_BIRD_COUNT;
            
            // 4. Re-initialize the flock based on the reset count
            handleBirdCountChange();
        }

        // --- Event Handlers ---

        function handleBirdCountChange() {
            const newCount = parseInt(birdCountInput.value, 10);
            currentBirdCountSpan.textContent = newCount;
            
            targetBirdCount = newCount;
            
            // Clear any pending settling timer
            if (settleTimeout) {
                clearTimeout(settleTimeout);
                settleTimeout = null;
            }

            if (targetBirdCount < birds.length) {
                // If the target is lowered, immediately stop peeling and reset
                if (additionInterval) {
                    clearInterval(additionInterval);
                    additionInterval = null;
                }
                if (peelInterval) {
                    clearInterval(peelInterval);
                    peelInterval = null;
                }
                
                birds.length = targetBirdCount;
                isFlockFormed = true; 
                
                // Reset states of remaining birds to FLOCKING if they were roosting
                birds.forEach(b => { 
                    b.roostingState = 'FLOCKING'; 
                    b.color = '#FFFFFF';
                    b.roostTarget = null;
                });

                updateArrivedCount();
                startRoostingPeel(); // Start peeling for the new, smaller flock

            } else if (targetBirdCount > birds.length && additionInterval === null) {
                // Start arrival of new birds
                isFlockFormed = false;
                if (peelInterval) { // Stop peeling while new birds are arriving
                    clearInterval(peelInterval);
                    peelInterval = null;
                }
                additionInterval = setInterval(addSingleBird, ARRIVAL_INTERVAL_MS); 
            } else if (targetBirdCount <= birds.length && additionInterval !== null) {
                // Stop arrival if slider hits current count
                clearInterval(additionInterval);
                additionInterval = null;
                // Since the count matches, start the settling timeout
                if (settleTimeout) clearTimeout(settleTimeout); 
                settleTimeout = setTimeout(() => {
                    isFlockFormed = true; 
                    startRoostingPeel();
                    settleTimeout = null;
                }, FLOCK_SETTLE_DELAY_MS);
            }
            
            updateArrivedCount();
        }

        // Mouse/Touch Tracking (Attraction Point)
        let isDragging = false;

        function getClientPos(event) {
            if (event.touches) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        function handleStart(event) {
            isDragging = true;
            handleMove(event);
        }

        function handleMove(event) {
            if (!isDragging) return;
            const pos = getClientPos(event);
            const rect = canvas.getBoundingClientRect();
            
            attractionPoint = new Vector(
                pos.x - rect.left, 
                pos.y - rect.top
            );
            event.preventDefault(); 
        }

        function handleEnd() {
            isDragging = false;
            attractionPoint = null; 
        }

        // Add Listeners
        window.addEventListener('resize', () => {
            resizeCanvas();
        });
        
        birdCountInput.addEventListener('input', handleBirdCountChange);
        addBirdsButton.addEventListener('click', increaseTargetCount); 
        resetButton.addEventListener('click', resetSimulation); 

        // Mouse/Touch Listeners for Attraction
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);


        // Initialization
        window.onload = () => {
            resizeCanvas();
            
            loop(); 

            // Initialize the UI and state
            updateArrivedCount();

            targetBirdCount = parseInt(birdCountInput.value, 10); 
            handleBirdCountChange(); 
        };

    </script>
</body>
</html>
